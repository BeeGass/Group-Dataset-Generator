#!/usr/bin/env python3
"""
Exhaustive tests for individual dihedral group datasets (D3-D20).
"""

import pytest
from .test_base_individual import BaseIndividualGroupTest


class TestDihedralIndividual(BaseIndividualGroupTest):
    """Exhaustive tests for individual dihedral group datasets."""

    GROUP_TYPE = "dihedral"
    GROUP_CONFIG = {
        "degrees": list(range(3, 21)),  # D3 through D20
        "orders": {i: 2*i for i in range(3, 21)},  # Dihedral groups have order 2n
        "prefix": "D",
    }

    # Override to test all dihedral group degrees
    @pytest.mark.parametrize("degree", list(range(3, 21)))
    def test_group_properties(self, degree):
        """Test group properties for each dihedral degree."""
        super().test_group_properties(degree)

    def test_dihedral_order_formula(self):
        """Test that dihedral groups Dn have order 2n."""
        for degree in self.GROUP_CONFIG["degrees"]:
            expected_order = 2 * degree
            actual_order = self.GROUP_CONFIG["orders"][degree]
            assert actual_order == expected_order, (
                f"D{degree} should have order {expected_order}, config has {actual_order}"
            )

            # Verify in dataset
            dataset = self.load_individual_dataset(degree)
            assert dataset[0]["group_order"] == expected_order

    def test_geometric_interpretation(self):
        """Test properties related to geometric interpretation of dihedral groups."""
        # Dihedral groups represent symmetries of regular polygons
        # D3 = symmetries of equilateral triangle
        # D4 = symmetries of square
        # etc.

        for degree in [3, 4, 5]:
            dataset = self.load_individual_dataset(degree)

            # Each Dn has n rotations and n reflections
            # Total elements = 2n
            assert dataset[0]["group_order"] == 2 * degree
            assert dataset[0]["group_degree"] == degree

    def test_generator_structure(self):
        """Test that dihedral groups are generated by rotation and reflection."""
        # Dn is generated by:
        # r = rotation by 2π/n
        # s = reflection
        # With relations: r^n = 1, s^2 = 1, srs = r^(-1)

        for degree in [4, 6]:
            dataset = self.load_individual_dataset(degree)

            # The group has 2n elements:
            # n rotations: 1, r, r^2, ..., r^(n-1)
            # n reflections: s, sr, sr^2, ..., sr^(n-1)

            # Identity element is 0
            # Element 1 might be the basic rotation r
            # But exact encoding depends on implementation
            assert len(dataset) > 0

    def test_non_abelian_property(self):
        """Test that dihedral groups (except D1, D2) are non-abelian."""
        # For n ≥ 3, Dn is non-abelian
        # This means rs ≠ sr in general

        for degree in [3, 4, 5]:
            dataset = self.load_individual_dataset(degree)

            # For non-abelian groups, we should find examples where
            # composing a,b gives different result than b,a
            # This is a mathematical property we're acknowledging
            assert dataset[0]["group_order"] == 2 * degree

    def test_d3_isomorphic_to_s3(self):
        """Test that D3 is isomorphic to S3."""
        # D3 (symmetries of triangle) is isomorphic to S3
        d3_dataset = self.load_individual_dataset(3)

        assert d3_dataset[0]["group_order"] == 6
        assert d3_dataset[0]["group_degree"] == 3

        # Both groups have order 6 and are the smallest non-abelian groups

    def test_d4_special_properties(self):
        """Test special properties of D4 (square symmetries)."""
        d4_dataset = self.load_individual_dataset(4)

        assert d4_dataset[0]["group_order"] == 8
        assert d4_dataset[0]["group_degree"] == 4

        # D4 has interesting subgroup structure:
        # - Cyclic subgroup of order 4 (rotations)
        # - Three subgroups of order 2 (180° rotation, two reflections)
        # - Klein four-group as a subgroup

    def test_subgroup_structure(self):
        """Test subgroup structure of dihedral groups."""
        # Every dihedral group Dn contains:
        # - Cyclic subgroup Cn of order n (all rotations)
        # - n subgroups of order 2 (each reflection generates one)

        for degree in [6, 8]:
            dataset = self.load_individual_dataset(degree)

            # The cyclic subgroup of rotations has order n
            # Each reflection has order 2
            assert dataset[0]["group_order"] == 2 * degree

    def test_composition_properties(self):
        """Test composition properties specific to dihedral groups."""
        # In Dn:
        # - Composing two rotations gives a rotation
        # - Composing two reflections gives a rotation
        # - Composing rotation and reflection gives a reflection

        for degree in [4, 5]:
            dataset = self.load_individual_dataset(degree)

            # Sample some compositions
            short_sequences = []
            for i in range(min(50, len(dataset))):
                if dataset[i]["sequence_length"] <= 3:
                    short_sequences.append(dataset[i])

            # All elements should be in valid range [0, 2n)
            for sample in short_sequences:
                input_ids = [int(x) for x in sample["input_sequence"].split()]
                assert all(0 <= x < 2 * degree for x in input_ids)
                target_id = int(sample["target"])
                assert 0 <= target_id < 2 * degree

    def test_large_dihedral_groups(self):
        """Test properties of larger dihedral groups."""
        large_degrees = [12, 15, 20]

        for degree in large_degrees:
            dataset = self.load_individual_dataset(degree)

            # Should have substantial data
            assert len(dataset) > 1000

            # Verify order
            assert dataset[0]["group_order"] == 2 * degree

            # These represent symmetries of regular 12-gon, 15-gon, 20-gon

    @pytest.mark.parametrize("n", [3, 4, 5, 6])
    def test_element_orders(self, n):
        """Test orders of elements in dihedral groups."""
        dataset = self.load_individual_dataset(n)

        # In Dn:
        # - Identity has order 1
        # - Rotations by 2πk/n have order n/gcd(n,k)
        # - All reflections have order 2

        # This is a mathematical property
        # The dataset should reflect these constraints
        assert dataset[0]["group_degree"] == n
        assert dataset[0]["group_order"] == 2 * n
