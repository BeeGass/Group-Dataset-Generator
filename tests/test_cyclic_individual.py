#!/usr/bin/env python3
"""
Exhaustive tests for individual cyclic group datasets (C3-C30).
"""

import pytest
from .test_base_individual import BaseIndividualGroupTest
import math


class TestCyclicIndividual(BaseIndividualGroupTest):
    """Exhaustive tests for individual cyclic group datasets."""

    GROUP_TYPE = "cyclic"
    GROUP_CONFIG = {
        "degrees": list(range(2, 31)),  # C2 through C30
        "orders": {i: i for i in range(2, 31)},  # For cyclic groups, order = degree
        "prefix": "C",
    }

    # Override to test all cyclic group degrees
    @pytest.mark.parametrize("degree", list(range(2, 31)))
    def test_group_properties(self, degree):
        """Test group properties for each cyclic degree."""
        super().test_group_properties(degree)

    def test_cyclic_order_equals_degree(self):
        """Test that cyclic groups Cn have order n."""
        for degree in self.GROUP_CONFIG["degrees"]:
            expected_order = degree  # For cyclic groups, order = degree
            actual_order = self.GROUP_CONFIG["orders"][degree]
            assert actual_order == expected_order, (
                f"C{degree} should have order {expected_order}, config has {actual_order}"
            )

            # Verify in dataset
            dataset = self.load_individual_dataset(degree)
            assert dataset[0]["group_order"] == expected_order
            assert dataset[0]["group_degree"] == degree

    def test_abelian_property(self):
        """Test that all cyclic groups are abelian (commutative)."""
        # For cyclic groups, composition is just addition mod n
        # So a ∘ b = b ∘ a for all elements

        for degree in [3, 5, 7]:  # Test a few prime cyclic groups
            dataset = self.load_individual_dataset(degree)

            # Find examples with same elements in different order
            commutative_pairs = []
            for i in range(min(100, len(dataset))):
                sample = dataset[i]
                input_ids = [int(x) for x in sample["input_sequence"].split()]
                if len(input_ids) == 2:
                    a, b = input_ids
                    if a != b:  # Different elements
                        commutative_pairs.append((a, b, sample["target"]))

            # In cyclic groups, composition is addition mod n
            for a, b, target in commutative_pairs[:5]:
                expected = (a + b) % degree
                target_id = int(sample["target"])
                assert target_id == expected, (
                    f"C{degree}: {a} + {b} mod {degree} should be {expected}, got {target_id}"
                )

    def test_generator_properties(self):
        """Test generator properties of cyclic groups."""
        # Every cyclic group Cn is generated by element 1
        # Powers of 1 give all elements: 1, 2, 3, ..., n-1, 0

        for degree in [
            5,
            7,
            11,
        ]:  # Test prime orders (all non-identity elements are generators)
            dataset = self.load_individual_dataset(degree)

            # Element 1 should generate the whole group
            # Composing 1 with itself k times gives element k mod n
            sequences_of_ones = []
            for i in range(min(50, len(dataset))):
                sample = dataset[i]
                input_ids = [int(x) for x in sample["input_sequence"].split()]
                if all(x == 1 for x in input_ids):
                    sequences_of_ones.append(sample)

            for sample in sequences_of_ones[:5]:
                k = len(sample["input_sequence"])
                expected_target = k % degree
                target_id = int(sample["target"])
                assert target_id == expected_target, (
                    f"C{degree}: 1^{k} should be {expected_target}, got {target_id}"
                )

    def test_prime_vs_composite_orders(self):
        """Test properties specific to prime vs composite order cyclic groups."""
        prime_orders = [3, 5, 7]
        composite_orders = [4, 6, 8, 9, 10, 12, 15, 20, 25, 30]

        # Prime order cyclic groups: all non-identity elements are generators
        for p in prime_orders:
            dataset = self.load_individual_dataset(p)
            assert dataset[0]["group_order"] == p
            # In Cp, elements 1, 2, ..., p-1 all generate the group

        # Composite order cyclic groups: have proper subgroups
        for n in composite_orders[:3]:
            dataset = self.load_individual_dataset(n)
            assert dataset[0]["group_order"] == n
            # Cn has subgroups of order d for each divisor d of n

    def test_cyclic_composition_formula(self):
        """Test that composition in cyclic groups follows addition mod n."""
        for degree in [4, 6, 10]:  # Test some composite orders
            dataset = self.load_individual_dataset(degree)

            errors = []
            # Test many compositions
            for i in range(min(200, len(dataset))):
                sample = dataset[i]
                input_seq = [int(x) for x in sample["input_sequence"].split()]
                target = int(sample["target"])

                # In Cn, composition is addition mod n
                expected = sum(input_seq) % degree

                if target != expected:
                    errors.append(
                        f"Sample {i}: sum({input_seq}) mod {degree} = {expected}, got {target}"
                    )

            assert len(errors) == 0, f"Composition errors in C{degree}:\n" + "\n".join(
                errors[:10]
            )

    def test_identity_element(self):
        """Test that 0 is the identity element in all cyclic groups."""
        for degree in self.GROUP_CONFIG["degrees"][:5]:
            dataset = self.load_individual_dataset(degree)

            # Find compositions involving 0
            identity_examples = []
            for i in range(min(50, len(dataset))):
                sample = dataset[i]
                input_ids = [int(x) for x in sample["input_sequence"].split()]
                if 0 in input_ids:
                    identity_examples.append(sample)

            # 0 + x = x for all x
            for sample in identity_examples[:10]:
                seq = [int(x) for x in sample["input_sequence"].split()]
                if len(seq) == 2:
                    if seq[0] == 0:
                        target_id = int(sample["target"])
                        assert target_id == seq[1], (
                            f"0 + {seq[1]} should be {seq[1]}, got {target_id}"
                        )
                    elif seq[1] == 0:
                        target_id = int(sample["target"])
                        assert target_id == seq[0], (
                            f"{seq[0]} + 0 should be {seq[0]}, got {target_id}"
                        )

    def test_inverse_elements(self):
        """Test inverse elements in cyclic groups."""
        for degree in [5, 7]:  # Test with prime orders
            dataset = self.load_individual_dataset(degree)

            # In Cn, the inverse of element a is (n - a) mod n
            # Find examples of inverse compositions
            for i in range(min(100, len(dataset))):
                sample = dataset[i]
                input_ids = [int(x) for x in sample["input_sequence"].split()]
                if len(input_ids) == 2:
                    a, b = input_ids
                    if (a + b) % degree == 0 and a != 0:
                        # a and b are inverses
                        target_id = int(sample["target"])
                        assert target_id == 0, (
                            f"C{degree}: {a} + {b} = 0 mod {degree}, but got {target_id}"
                        )

    def test_subgroup_structure(self):
        """Test subgroup structure of composite order cyclic groups."""
        # C12 has subgroups of orders 1, 2, 3, 4, 6, 12
        c12_dataset = self.load_individual_dataset(12)

        # Elements that generate subgroups:
        # 0: trivial subgroup {0}
        # 6: subgroup of order 2 {0, 6}
        # 4, 8: subgroup of order 3 {0, 4, 8}
        # 3, 9: subgroup of order 4 {0, 3, 6, 9}
        # 2, 10: subgroup of order 6 {0, 2, 4, 6, 8, 10}
        # 1, 5, 7, 11: generate all of C12

        # Find examples of elements from different subgroups
        subgroup_examples = {2: [], 3: [], 4: [], 6: []}
        for i in range(min(200, len(c12_dataset))):
            sample = c12_dataset[i]
            input_ids = [int(x) for x in sample["input_sequence"].split()]
            if len(input_ids) == 2 and input_ids[0] == input_ids[1]:
                elem = input_ids[0]
                if elem == 6:
                    subgroup_examples[2].append(sample)
                elif elem in [4, 8]:
                    subgroup_examples[3].append(sample)
                elif elem in [3, 9]:
                    subgroup_examples[4].append(sample)
                elif elem in [2, 10]:
                    subgroup_examples[6].append(sample)

        # Verify orders of elements
        if subgroup_examples[2]:  # Element 6 has order 2
            sample = subgroup_examples[2][0]
            target_id = int(sample["target"])
            assert target_id == 0, "6 + 6 should be 0 in C12"
